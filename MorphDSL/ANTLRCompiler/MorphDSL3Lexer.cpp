/** \file
 *  This C++ source file was generated by $ANTLR version 3.5
 *
 *     -  From the grammar source file : C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g
 *     -                            On : 2013-06-03 14:29:09
 *     -                 for the lexer : MorphDSL3LexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include "StdAfx.h"
#include    "MorphDSL3Lexer.hpp"
/* ----------------------------------------- */

namespace 	User  {
//AREA
  static ANTLR_UCHAR	lit_AREA[]  = { 0x41,0x52,0x45,0x41,    antlr3::ANTLR_STRING_TERMINATOR};
//ATTRIBUTE
  static ANTLR_UCHAR	lit_ATTRIBUTE[]  = { 0x41,0x54,0x54,0x52,0x49,0x42,0x55,0x54,0x45,    antlr3::ANTLR_STRING_TERMINATOR};
//BOX
  static ANTLR_UCHAR	lit_BOX[]  = { 0x42,0x4f,0x58,    antlr3::ANTLR_STRING_TERMINATOR};
//DAP
  static ANTLR_UCHAR	lit_DAP[]  = { 0x44,0x41,0x50,    antlr3::ANTLR_STRING_TERMINATOR};
//DMP
  static ANTLR_UCHAR	lit_DMP[]  = { 0x44,0x4d,0x50,    antlr3::ANTLR_STRING_TERMINATOR};
//EXTERNAL
  static ANTLR_UCHAR	lit_EXTERNAL[]  = { 0x45,0x58,0x54,0x45,0x52,0x4e,0x41,0x4c,    antlr3::ANTLR_STRING_TERMINATOR};
//INTERNAL
  static ANTLR_UCHAR	lit_INTERNAL[]  = { 0x49,0x4e,0x54,0x45,0x52,0x4e,0x41,0x4c,    antlr3::ANTLR_STRING_TERMINATOR};
//MORPHOLOGICAL
  static ANTLR_UCHAR	lit_MORPHOLOGICAL[]  = { 0x4d,0x4f,0x52,0x50,0x48,0x4f,0x4c,0x4f,0x47,0x49,0x43,0x41,0x4c,    antlr3::ANTLR_STRING_TERMINATOR};
//MSLS
  static ANTLR_UCHAR	lit_MSLS[]  = { 0x4d,0x53,0x4c,0x53,    antlr3::ANTLR_STRING_TERMINATOR};
//RECONSTRUCTION
  static ANTLR_UCHAR	lit_RECONSTRUCTION[]  = { 0x52,0x45,0x43,0x4f,0x4e,0x53,0x54,0x52,0x55,0x43,0x54,0x49,0x4f,0x4e,    antlr3::ANTLR_STRING_TERMINATOR};
//WATHERSHADE
  static ANTLR_UCHAR	lit_WATHERSHADE[]  = { 0x57,0x41,0x54,0x48,0x45,0x52,0x53,0x48,0x41,0x44,0x45,    antlr3::ANTLR_STRING_TERMINATOR};
//boundary
  static ANTLR_UCHAR	lit_boundary[]  = { 0x62,0x6f,0x75,0x6e,0x64,0x61,0x72,0x79,    antlr3::ANTLR_STRING_TERMINATOR};
//close
  static ANTLR_UCHAR	lit_close[]  = { 0x63,0x6c,0x6f,0x73,0x65,    antlr3::ANTLR_STRING_TERMINATOR};
//complement
  static ANTLR_UCHAR	lit_complement[]  = { 0x63,0x6f,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,    antlr3::ANTLR_STRING_TERMINATOR};
//crop
  static ANTLR_UCHAR	lit_crop[]  = { 0x63,0x72,0x6f,0x70,    antlr3::ANTLR_STRING_TERMINATOR};
//diferentialProfiles
  static ANTLR_UCHAR	lit_diferentialProfiles[]  = { 0x64,0x69,0x66,0x65,0x72,0x65,0x6e,0x74,0x69,0x61,0x6c,0x50,0x72,0x6f,0x66,0x69,0x6c,0x65,0x73,    antlr3::ANTLR_STRING_TERMINATOR};
//dilate
  static ANTLR_UCHAR	lit_dilate[]  = { 0x64,0x69,0x6c,0x61,0x74,0x65,    antlr3::ANTLR_STRING_TERMINATOR};
//distanceTransform
  static ANTLR_UCHAR	lit_distanceTransform[]  = { 0x64,0x69,0x73,0x74,0x61,0x6e,0x63,0x65,0x54,0x72,0x61,0x6e,0x73,0x66,0x6f,0x72,0x6d,    antlr3::ANTLR_STRING_TERMINATOR};
//erode
  static ANTLR_UCHAR	lit_erode[]  = { 0x65,0x72,0x6f,0x64,0x65,    antlr3::ANTLR_STRING_TERMINATOR};
//gradient
  static ANTLR_UCHAR	lit_gradient[]  = { 0x67,0x72,0x61,0x64,0x69,0x65,0x6e,0x74,    antlr3::ANTLR_STRING_TERMINATOR};
//hitmiss
  static ANTLR_UCHAR	lit_hitmiss[]  = { 0x68,0x69,0x74,0x6d,0x69,0x73,0x73,    antlr3::ANTLR_STRING_TERMINATOR};
//intersection
  static ANTLR_UCHAR	lit_intersection[]  = { 0x69,0x6e,0x74,0x65,0x72,0x73,0x65,0x63,0x74,0x69,0x6f,0x6e,    antlr3::ANTLR_STRING_TERMINATOR};
//load
  static ANTLR_UCHAR	lit_load[]  = { 0x6c,0x6f,0x61,0x64,    antlr3::ANTLR_STRING_TERMINATOR};
//mapping
  static ANTLR_UCHAR	lit_mapping[]  = { 0x6d,0x61,0x70,0x70,0x69,0x6e,0x67,    antlr3::ANTLR_STRING_TERMINATOR};
//multiply
  static ANTLR_UCHAR	lit_multiply[]  = { 0x6d,0x75,0x6c,0x74,0x69,0x70,0x6c,0x79,    antlr3::ANTLR_STRING_TERMINATOR};
//negate
  static ANTLR_UCHAR	lit_negate[]  = { 0x6e,0x65,0x67,0x61,0x74,0x65,    antlr3::ANTLR_STRING_TERMINATOR};
//normalize
  static ANTLR_UCHAR	lit_normalize[]  = { 0x6e,0x6f,0x72,0x6d,0x61,0x6c,0x69,0x7a,0x65,    antlr3::ANTLR_STRING_TERMINATOR};
//open
  static ANTLR_UCHAR	lit_open[]  = { 0x6f,0x70,0x65,0x6e,    antlr3::ANTLR_STRING_TERMINATOR};
//segmentation
  static ANTLR_UCHAR	lit_segmentation[]  = { 0x73,0x65,0x67,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,    antlr3::ANTLR_STRING_TERMINATOR};
//subtract
  static ANTLR_UCHAR	lit_subtract[]  = { 0x73,0x75,0x62,0x74,0x72,0x61,0x63,0x74,    antlr3::ANTLR_STRING_TERMINATOR};
//treshold
  static ANTLR_UCHAR	lit_treshold[]  = { 0x74,0x72,0x65,0x73,0x68,0x6f,0x6c,0x64,    antlr3::ANTLR_STRING_TERMINATOR};
//union
  static ANTLR_UCHAR	lit_union[]  = { 0x75,0x6e,0x69,0x6f,0x6e,    antlr3::ANTLR_STRING_TERMINATOR};
//without
  static ANTLR_UCHAR	lit_without[]  = { 0x77,0x69,0x74,0x68,0x6f,0x75,0x74,    antlr3::ANTLR_STRING_TERMINATOR};
}

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

	namespace 	User  {


/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



MorphDSL3Lexer::~MorphDSL3Lexer()
{
}

void
MorphDSL3Lexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "./MorphDSL3.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* MorphDSL3Lexer::getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called MorphDSL3Lexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pMorphDSL3Lexer initialized for the lex start
 *     - Fail NULL
 */
MorphDSL3Lexer::MorphDSL3Lexer(StreamType* instream)
:MorphDSL3LexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
	// See if we can create a new lexer with the standard constructor
	//
	this->init(instream );
}

/** \brief Create a new lexer called MorphDSL3Lexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pMorphDSL3Lexer initialized for the lex start
 *     - Fail NULL
 */
MorphDSL3Lexer::MorphDSL3Lexer(StreamType* instream, RecognizerSharedStateType* state)
:MorphDSL3LexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
	this->init(instream );
}

void MorphDSL3Lexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in MorphDSL3Lexer.h here so you can get a sense
     * of what goes where.
     */

}


/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__9 | T__10 | T__11 | T__12 | T__13 | T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | T__29 | T__30 | T__31 | T__32 | T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | T__40 | T__41 | T__42 | T__43 | T__44 | T__45 | T__46 | ID | DOUBLENUMBER | WS | COMMENT );
 */
static const ANTLR_INT32 dfa6_eot[290] =
    {
	-1, -1, -1, -1, -1, -1, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, -1, -1, -1, -1, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 99, 100, 101, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 29, 130, 29, -1, -1, -1, 29, 29, 29, 135, 29, 29, 
	29, 29, 29, 141, 29, 29, 29, 29, 29, 29, 29, 149, 29, 29, 29, 29, 154, 
	29, 29, 29, 29, 29, -1, 29, 29, 29, 29, -1, 29, 29, 29, 167, 29, -1, 29, 
	29, 29, 172, 29, 29, 29, -1, 29, 29, 29, 29, -1, 29, 29, 29, 183, 29, 29, 
	29, 29, 29, 29, 29, 29, -1, 29, 29, 194, 29, -1, 29, 29, 29, 29, 29, 201, 
	29, 29, 29, 29, -1, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, -1, 29, 29, 
	218, 29, 220, 29, -1, 29, 29, 29, 29, 226, 29, 228, 229, 29, 29, 29, 233, 
	29, 29, 29, 237, -1, 29, -1, 239, 29, 29, 242, 243, -1, 244, -1, -1, 29, 
	29, 29, -1, 29, 29, 29, -1, 29, -1, 252, 29, -1, -1, -1, 29, 29, 29, 257, 
	29, 29, 29, -1, 29, 29, 29, 264, -1, 29, 29, 29, 29, 29, 29, -1, 29, 29, 
	273, 274, 275, 29, 29, 29, -1, -1, -1, 279, 29, 29, -1, 29, 29, 29, 29, 
	29, 287, 29, -1, 289, -1
    };
static const ANTLR_INT32 dfa6_eof[290] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa6_min[290] =
    {
	9, -1, -1, -1, -1, -1, 82, 79, 65, 88, 78, 79, 69, 65, 111, 108, 105, 114, 
	114, 105, 110, 111, 97, 101, 112, 101, 114, 110, 105, -1, -1, -1, -1, 69, 
	84, 88, 80, 80, 84, 84, 82, 76, 67, 84, 117, 111, 109, 111, 102, 111, 97, 
	116, 116, 97, 112, 108, 103, 114, 101, 103, 98, 101, 105, 116, 65, 82, 
	46, 46, 46, 69, 69, 80, 83, 79, 72, 110, 115, 112, 112, 101, 97, 116, 100, 
	100, 109, 101, 100, 112, 116, 97, 109, 110, 109, 116, 115, 111, 104, 46, 
	73, -1, -1, -1, 82, 82, 72, 46, 78, 69, 100, 101, 108, 46, 114, 116, 97, 
	101, 105, 105, 114, 46, 105, 105, 116, 97, 46, 101, 114, 104, 110, 111, 
	-1, 66, 78, 78, 79, -1, 83, 82, 97, 46, 101, -1, 101, 101, 110, 46, 101, 
	115, 115, -1, 110, 112, 101, 108, -1, 110, 97, 111, 46, 117, 85, 65, 65, 
	76, 84, 83, 114, -1, 109, 110, 46, 99, -1, 110, 115, 101, 103, 108, 46, 
	105, 116, 99, 108, -1, 116, 84, 76, 76, 79, 82, 72, 121, 101, 116, -1, 
	101, 116, 46, 99, 46, 121, -1, 122, 97, 116, 100, 46, 69, 46, 46, 71, 85, 
	65, 46, 110, 105, 84, 46, -1, 116, -1, 46, 101, 116, 46, 46, -1, 46, -1, 
	-1, 73, 67, 68, -1, 116, 97, 114, -1, 105, -1, 46, 105, -1, -1, -1, 67, 
	84, 69, 46, 108, 97, 111, -1, 111, 65, 73, 46, -1, 80, 110, 110, 110, 76, 
	79, -1, 114, 115, 46, 46, 46, 78, 111, 102, -1, -1, -1, 46, 102, 111, -1, 
	105, 114, 108, 109, 101, 46, 115, -1, 46, -1
    };
static const ANTLR_INT32 dfa6_max[290] =
    {
	122, -1, -1, -1, -1, -1, 84, 79, 77, 88, 78, 83, 69, 65, 111, 114, 105, 
	114, 114, 105, 110, 111, 117, 111, 112, 117, 114, 110, 105, -1, -1, -1, 
	-1, 69, 84, 88, 80, 80, 84, 84, 82, 76, 67, 84, 117, 111, 109, 111, 115, 
	111, 97, 116, 116, 97, 112, 108, 103, 114, 101, 103, 98, 101, 105, 116, 
	65, 82, 122, 122, 122, 69, 69, 80, 83, 79, 72, 110, 115, 112, 112, 101, 
	97, 116, 100, 100, 109, 101, 100, 112, 116, 97, 109, 110, 109, 116, 115, 
	111, 104, 122, 73, -1, -1, -1, 82, 82, 72, 122, 78, 69, 100, 101, 108, 
	122, 114, 116, 97, 101, 105, 105, 114, 122, 105, 105, 116, 97, 122, 101, 
	114, 104, 110, 111, -1, 66, 78, 78, 79, -1, 83, 82, 97, 122, 101, -1, 101, 
	101, 110, 122, 101, 115, 115, -1, 110, 112, 101, 108, -1, 110, 97, 111, 
	122, 117, 85, 65, 65, 76, 84, 83, 114, -1, 109, 110, 122, 99, -1, 110, 
	115, 101, 103, 108, 122, 105, 116, 99, 108, -1, 116, 84, 76, 76, 79, 82, 
	72, 121, 101, 116, -1, 101, 116, 122, 99, 122, 121, -1, 122, 97, 116, 100, 
	122, 69, 122, 122, 71, 85, 65, 122, 110, 105, 84, 122, -1, 116, -1, 122, 
	101, 116, 122, 122, -1, 122, -1, -1, 73, 67, 68, -1, 116, 97, 114, -1, 
	105, -1, 122, 105, -1, -1, -1, 67, 84, 69, 122, 108, 97, 111, -1, 111, 
	65, 73, 122, -1, 80, 110, 110, 110, 76, 79, -1, 114, 115, 122, 122, 122, 
	78, 111, 102, -1, -1, -1, 122, 102, 111, -1, 105, 114, 108, 109, 101, 122, 
	115, -1, 122, -1
    };
static const ANTLR_INT32 dfa6_accept[290] =
    {
	-1, 1, 2, 3, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, 40, 41, 42, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, 
	-1, -1, -1, 28, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 18, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, 
	-1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	26, -1, 29, -1, -1, -1, -1, -1, 38, -1, 11, 12, -1, -1, -1, 17, -1, -1, 
	-1, 25, -1, 30, -1, -1, 35, 36, 7, -1, -1, -1, -1, -1, -1, -1, 32, -1, 
	-1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, 
	-1, 27, 34, 13, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, 23, -1, 21
    };
static const ANTLR_INT32 dfa6_special[290] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa6_T_empty	 =   NULL;

static const ANTLR_INT32 dfa6_T0[] =
    {
	284
    };

static const ANTLR_INT32 dfa6_T1[] =
    {
	286
    };

static const ANTLR_INT32 dfa6_T2[] =
    {
	288
    };

static const ANTLR_INT32 dfa6_T3[] =
    {
	271
    };

static const ANTLR_INT32 dfa6_T4[] =
    {
	277
    };

static const ANTLR_INT32 dfa6_T5[] =
    {
	29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, 
	-1, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, -1, -1, 29, -1, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
	29, 29, 29, 29, 29
    };

static const ANTLR_INT32 dfa6_T6[] =
    {
	280
    };

static const ANTLR_INT32 dfa6_T7[] =
    {
	282
    };

static const ANTLR_INT32 dfa6_T8[] =
    {
	36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37
    };

static const ANTLR_INT32 dfa6_T9[] =
    {
	235
    };

static const ANTLR_INT32 dfa6_T10[] =
    {
	249
    };

static const ANTLR_INT32 dfa6_T11[] =
    {
	258
    };

static const ANTLR_INT32 dfa6_T12[] =
    {
	265
    };

static const ANTLR_INT32 dfa6_T13[] =
    {
	142
    };

static const ANTLR_INT32 dfa6_T14[] =
    {
	169
    };

static const ANTLR_INT32 dfa6_T15[] =
    {
	193
    };

static const ANTLR_INT32 dfa6_T16[] =
    {
	215
    };

static const ANTLR_INT32 dfa6_T17[] =
    {
	112
    };

static const ANTLR_INT32 dfa6_T18[] =
    {
	54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 55
    };

static const ANTLR_INT32 dfa6_T19[] =
    {
	111
    };

static const ANTLR_INT32 dfa6_T20[] =
    {
	45, -1, -1, 46, -1, -1, 47
    };

static const ANTLR_INT32 dfa6_T21[] =
    {
	78
    };

static const ANTLR_INT32 dfa6_T22[] =
    {
	248
    };

static const ANTLR_INT32 dfa6_T23[] =
    {
	234
    };

static const ANTLR_INT32 dfa6_T24[] =
    {
	192
    };

static const ANTLR_INT32 dfa6_T25[] =
    {
	214
    };

static const ANTLR_INT32 dfa6_T26[] =
    {
	140
    };

static const ANTLR_INT32 dfa6_T27[] =
    {
	168
    };

static const ANTLR_INT32 dfa6_T28[] =
    {
	77
    };

static const ANTLR_INT32 dfa6_T29[] =
    {
	110
    };

static const ANTLR_INT32 dfa6_T30[] =
    {
	56, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57
    };

static const ANTLR_INT32 dfa6_T31[] =
    {
	139
    };

static const ANTLR_INT32 dfa6_T32[] =
    {
	76
    };

static const ANTLR_INT32 dfa6_T33[] =
    {
	109
    };

static const ANTLR_INT32 dfa6_T34[] =
    {
	213
    };

static const ANTLR_INT32 dfa6_T35[] =
    {
	191
    };

static const ANTLR_INT32 dfa6_T36[] =
    {
	33, -1, 34
    };

static const ANTLR_INT32 dfa6_T37[] =
    {
	166
    };

static const ANTLR_INT32 dfa6_T38[] =
    {
	138
    };

static const ANTLR_INT32 dfa6_T39[] =
    {
	108
    };

static const ANTLR_INT32 dfa6_T40[] =
    {
	75
    };

static const ANTLR_INT32 dfa6_T41[] =
    {
	44
    };

static const ANTLR_INT32 dfa6_T42[] =
    {
	256
    };

static const ANTLR_INT32 dfa6_T43[] =
    {
	247
    };

static const ANTLR_INT32 dfa6_T44[] =
    {
	43
    };

static const ANTLR_INT32 dfa6_T45[] =
    {
	74
    };

static const ANTLR_INT32 dfa6_T46[] =
    {
	107
    };

static const ANTLR_INT32 dfa6_T47[] =
    {
	137
    };

static const ANTLR_INT32 dfa6_T48[] =
    {
	165
    };

static const ANTLR_INT32 dfa6_T49[] =
    {
	190
    };

static const ANTLR_INT32 dfa6_T50[] =
    {
	212
    };

static const ANTLR_INT32 dfa6_T51[] =
    {
	232
    };

static const ANTLR_INT32 dfa6_T52[] =
    {
	255
    };

static const ANTLR_INT32 dfa6_T53[] =
    {
	263
    };

static const ANTLR_INT32 dfa6_T54[] =
    {
	270
    };

static const ANTLR_INT32 dfa6_T55[] =
    {
	276
    };

static const ANTLR_INT32 dfa6_T56[] =
    {
	106
    };

static const ANTLR_INT32 dfa6_T57[] =
    {
	73
    };

static const ANTLR_INT32 dfa6_T58[] =
    {
	164
    };

static const ANTLR_INT32 dfa6_T59[] =
    {
	31, 31, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 31, -1, 1, -1, -1, -1, -1, -1, 2, 3, -1, -1, 4, -1, 
	29, 32, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 29, -1, -1, 5, -1, -1, 
	-1, 6, 7, 29, 8, 9, 29, 29, 29, 10, 29, 29, 29, 11, 29, 29, 29, 29, 12, 
	29, 29, 29, 29, 13, 29, 29, 29, -1, 29, -1, -1, 29, -1, 29, 14, 15, 16, 
	17, 29, 18, 19, 20, 29, 29, 21, 22, 23, 24, 29, 29, 29, 25, 26, 27, 29, 
	28, 29, 29, 29
    };

static const ANTLR_INT32 dfa6_T60[] =
    {
	136
    };

static const ANTLR_INT32 dfa6_T61[] =
    {
	211
    };

static const ANTLR_INT32 dfa6_T62[] =
    {
	189
    };

static const ANTLR_INT32 dfa6_T63[] =
    {
	246
    };

static const ANTLR_INT32 dfa6_T64[] =
    {
	231
    };

static const ANTLR_INT32 dfa6_T65[] =
    {
	72
    };

static const ANTLR_INT32 dfa6_T66[] =
    {
	105
    };

static const ANTLR_INT32 dfa6_T67[] =
    {
	42
    };

static const ANTLR_INT32 dfa6_T68[] =
    {
	262
    };

static const ANTLR_INT32 dfa6_T69[] =
    {
	269
    };

static const ANTLR_INT32 dfa6_T70[] =
    {
	245
    };

static const ANTLR_INT32 dfa6_T71[] =
    {
	254
    };

static const ANTLR_INT32 dfa6_T72[] =
    {
	104
    };

static const ANTLR_INT32 dfa6_T73[] =
    {
	134
    };

static const ANTLR_INT32 dfa6_T74[] =
    {
	71
    };

static const ANTLR_INT32 dfa6_T75[] =
    {
	210
    };

static const ANTLR_INT32 dfa6_T76[] =
    {
	230
    };

static const ANTLR_INT32 dfa6_T77[] =
    {
	163
    };

static const ANTLR_INT32 dfa6_T78[] =
    {
	188
    };

static const ANTLR_INT32 dfa6_T79[] =
    {
	209
    };

static const ANTLR_INT32 dfa6_T80[] =
    {
	187
    };

static const ANTLR_INT32 dfa6_T81[] =
    {
	162
    };

static const ANTLR_INT32 dfa6_T82[] =
    {
	133
    };

static const ANTLR_INT32 dfa6_T83[] =
    {
	208
    };

static const ANTLR_INT32 dfa6_T84[] =
    {
	103
    };

static const ANTLR_INT32 dfa6_T85[] =
    {
	70
    };

static const ANTLR_INT32 dfa6_T86[] =
    {
	39
    };

static const ANTLR_INT32 dfa6_T87[] =
    {
	179
    };

static const ANTLR_INT32 dfa6_T88[] =
    {
	153
    };

static const ANTLR_INT32 dfa6_T89[] =
    {
	222
    };

static const ANTLR_INT32 dfa6_T90[] =
    {
	202
    };

static const ANTLR_INT32 dfa6_T91[] =
    {
	123
    };

static const ANTLR_INT32 dfa6_T92[] =
    {
	90
    };

static const ANTLR_INT32 dfa6_T93[] =
    {
	58
    };

static const ANTLR_INT32 dfa6_T94[] =
    {
	124
    };

static const ANTLR_INT32 dfa6_T95[] =
    {
	91
    };

static const ANTLR_INT32 dfa6_T96[] =
    {
	240
    };

static const ANTLR_INT32 dfa6_T97[] =
    {
	151
    };

static const ANTLR_INT32 dfa6_T98[] =
    {
	177
    };

static const ANTLR_INT32 dfa6_T99[] =
    {
	200
    };

static const ANTLR_INT32 dfa6_T100[] =
    {
	221
    };

static const ANTLR_INT32 dfa6_T101[] =
    {
	178
    };

static const ANTLR_INT32 dfa6_T102[] =
    {
	89
    };

static const ANTLR_INT32 dfa6_T103[] =
    {
	122
    };

static const ANTLR_INT32 dfa6_T104[] =
    {
	152
    };

static const ANTLR_INT32 dfa6_T105[] =
    {
	176
    };

static const ANTLR_INT32 dfa6_T106[] =
    {
	150
    };

static const ANTLR_INT32 dfa6_T107[] =
    {
	120
    };

static const ANTLR_INT32 dfa6_T108[] =
    {
	87
    };

static const ANTLR_INT32 dfa6_T109[] =
    {
	121
    };

static const ANTLR_INT32 dfa6_T110[] =
    {
	88
    };

static const ANTLR_INT32 dfa6_T111[] =
    {
	199
    };

static const ANTLR_INT32 dfa6_T112[] =
    {
	260
    };

static const ANTLR_INT32 dfa6_T113[] =
    {
	267
    };

static const ANTLR_INT32 dfa6_T114[] =
    {
	238
    };

static const ANTLR_INT32 dfa6_T115[] =
    {
	251
    };

static const ANTLR_INT32 dfa6_T116[] =
    {
	198
    };

static const ANTLR_INT32 dfa6_T117[] =
    {
	219
    };

static const ANTLR_INT32 dfa6_T118[] =
    {
	148
    };

static const ANTLR_INT32 dfa6_T119[] =
    {
	175
    };

static const ANTLR_INT32 dfa6_T120[] =
    {
	119
    };

static const ANTLR_INT32 dfa6_T121[] =
    {
	53
    };

static const ANTLR_INT32 dfa6_T122[] =
    {
	86
    };

static const ANTLR_INT32 dfa6_T123[] =
    {
	40, -1, -1, -1, 41
    };

static const ANTLR_INT32 dfa6_T124[] =
    {
	51
    };

static const ANTLR_INT32 dfa6_T125[] =
    {
	117
    };

static const ANTLR_INT32 dfa6_T126[] =
    {
	84
    };

static const ANTLR_INT32 dfa6_T127[] =
    {
	174
    };

static const ANTLR_INT32 dfa6_T128[] =
    {
	147
    };

static const ANTLR_INT32 dfa6_T129[] =
    {
	197
    };

static const ANTLR_INT32 dfa6_T130[] =
    {
	52
    };

static const ANTLR_INT32 dfa6_T131[] =
    {
	118
    };

static const ANTLR_INT32 dfa6_T132[] =
    {
	85
    };

static const ANTLR_INT32 dfa6_T133[] =
    {
	49
    };

static const ANTLR_INT32 dfa6_T134[] =
    {
	82
    };

static const ANTLR_INT32 dfa6_T135[] =
    {
	115
    };

static const ANTLR_INT32 dfa6_T136[] =
    {
	145
    };

static const ANTLR_INT32 dfa6_T137[] =
    {
	50
    };

static const ANTLR_INT32 dfa6_T138[] =
    {
	83
    };

static const ANTLR_INT32 dfa6_T139[] =
    {
	116
    };

static const ANTLR_INT32 dfa6_T140[] =
    {
	146
    };

static const ANTLR_INT32 dfa6_T141[] =
    {
	173
    };

static const ANTLR_INT32 dfa6_T142[] =
    {
	196
    };

static const ANTLR_INT32 dfa6_T143[] =
    {
	217
    };

static const ANTLR_INT32 dfa6_T144[] =
    {
	236
    };

static const ANTLR_INT32 dfa6_T145[] =
    {
	216
    };

static const ANTLR_INT32 dfa6_T146[] =
    {
	195
    };

static const ANTLR_INT32 dfa6_T147[] =
    {
	171
    };

static const ANTLR_INT32 dfa6_T148[] =
    {
	272
    };

static const ANTLR_INT32 dfa6_T149[] =
    {
	79, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, 81
    };

static const ANTLR_INT32 dfa6_T150[] =
    {
	266
    };

static const ANTLR_INT32 dfa6_T151[] =
    {
	59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60
    };

static const ANTLR_INT32 dfa6_T152[] =
    {
	259
    };

static const ANTLR_INT32 dfa6_T153[] =
    {
	250
    };

static const ANTLR_INT32 dfa6_T154[] =
    {
	285
    };

static const ANTLR_INT32 dfa6_T155[] =
    {
	283
    };

static const ANTLR_INT32 dfa6_T156[] =
    {
	281
    };

static const ANTLR_INT32 dfa6_T157[] =
    {
	278
    };

static const ANTLR_INT32 dfa6_T158[] =
    {
	143
    };

static const ANTLR_INT32 dfa6_T159[] =
    {
	170
    };

static const ANTLR_INT32 dfa6_T160[] =
    {
	113
    };

static const ANTLR_INT32 dfa6_T161[] =
    {
	48
    };

static const ANTLR_INT32 dfa6_T162[] =
    {
	114
    };

static const ANTLR_INT32 dfa6_T163[] =
    {
	144
    };

static const ANTLR_INT32 dfa6_T164[] =
    {
	261
    };

static const ANTLR_INT32 dfa6_T165[] =
    {
	253
    };

static const ANTLR_INT32 dfa6_T166[] =
    {
	268
    };

static const ANTLR_INT32 dfa6_T167[] =
    {
	203
    };

static const ANTLR_INT32 dfa6_T168[] =
    {
	180
    };

static const ANTLR_INT32 dfa6_T169[] =
    {
	241
    };

static const ANTLR_INT32 dfa6_T170[] =
    {
	223
    };

static const ANTLR_INT32 dfa6_T171[] =
    {
	92
    };

static const ANTLR_INT32 dfa6_T172[] =
    {
	155
    };

static const ANTLR_INT32 dfa6_T173[] =
    {
	125
    };

static const ANTLR_INT32 dfa6_T174[] =
    {
	61
    };

static const ANTLR_INT32 dfa6_T175[] =
    {
	94
    };

static const ANTLR_INT32 dfa6_T176[] =
    {
	204
    };

static const ANTLR_INT32 dfa6_T177[] =
    {
	224
    };

static const ANTLR_INT32 dfa6_T178[] =
    {
	93
    };

static const ANTLR_INT32 dfa6_T179[] =
    {
	126
    };

static const ANTLR_INT32 dfa6_T180[] =
    {
	156
    };

static const ANTLR_INT32 dfa6_T181[] =
    {
	181
    };

static const ANTLR_INT32 dfa6_T182[] =
    {
	158
    };

static const ANTLR_INT32 dfa6_T183[] =
    {
	128
    };

static const ANTLR_INT32 dfa6_T184[] =
    {
	95
    };

static const ANTLR_INT32 dfa6_T185[] =
    {
	62
    };

static const ANTLR_INT32 dfa6_T186[] =
    {
	225
    };

static const ANTLR_INT32 dfa6_T187[] =
    {
	205
    };

static const ANTLR_INT32 dfa6_T188[] =
    {
	182
    };

static const ANTLR_INT32 dfa6_T189[] =
    {
	157
    };

static const ANTLR_INT32 dfa6_T190[] =
    {
	127
    };

static const ANTLR_INT32 dfa6_T191[] =
    {
	206
    };

static const ANTLR_INT32 dfa6_T192[] =
    {
	159
    };

static const ANTLR_INT32 dfa6_T193[] =
    {
	184
    };

static const ANTLR_INT32 dfa6_T194[] =
    {
	96
    };

static const ANTLR_INT32 dfa6_T195[] =
    {
	129
    };

static const ANTLR_INT32 dfa6_T196[] =
    {
	63
    };

static const ANTLR_INT32 dfa6_T197[] =
    {
	207
    };

static const ANTLR_INT32 dfa6_T198[] =
    {
	227
    };

static const ANTLR_INT32 dfa6_T199[] =
    {
	160
    };

static const ANTLR_INT32 dfa6_T200[] =
    {
	185
    };

static const ANTLR_INT32 dfa6_T201[] =
    {
	67
    };

static const ANTLR_INT32 dfa6_T202[] =
    {
	35
    };

static const ANTLR_INT32 dfa6_T203[] =
    {
	66
    };

static const ANTLR_INT32 dfa6_T204[] =
    {
	68
    };

static const ANTLR_INT32 dfa6_T205[] =
    {
	186
    };

static const ANTLR_INT32 dfa6_T206[] =
    {
	161
    };

static const ANTLR_INT32 dfa6_T207[] =
    {
	132
    };

static const ANTLR_INT32 dfa6_T208[] =
    {
	102
    };

static const ANTLR_INT32 dfa6_T209[] =
    {
	69
    };

static const ANTLR_INT32 dfa6_T210[] =
    {
	38
    };

static const ANTLR_INT32 dfa6_T211[] =
    {
	97
    };

static const ANTLR_INT32 dfa6_T212[] =
    {
	64
    };

static const ANTLR_INT32 dfa6_T213[] =
    {
	65
    };

static const ANTLR_INT32 dfa6_T214[] =
    {
	131
    };

static const ANTLR_INT32 dfa6_T215[] =
    {
	98
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa6_transitions[] =
{
    dfa6_T59, NULL, NULL, NULL, NULL, NULL, dfa6_T36, dfa6_T202, dfa6_T8, 
    dfa6_T210, dfa6_T86, dfa6_T123, dfa6_T67, dfa6_T44, dfa6_T41, dfa6_T20, 
    dfa6_T161, dfa6_T133, dfa6_T137, dfa6_T124, dfa6_T130, dfa6_T121, dfa6_T18, 
    dfa6_T30, dfa6_T93, dfa6_T151, dfa6_T174, dfa6_T185, dfa6_T196, NULL, 
    NULL, NULL, NULL, dfa6_T212, dfa6_T213, dfa6_T203, dfa6_T201, dfa6_T204, 
    dfa6_T209, dfa6_T85, dfa6_T74, dfa6_T65, dfa6_T57, dfa6_T45, dfa6_T40, 
    dfa6_T32, dfa6_T28, dfa6_T21, dfa6_T149, dfa6_T134, dfa6_T138, dfa6_T126, 
    dfa6_T132, dfa6_T122, dfa6_T108, dfa6_T110, dfa6_T102, dfa6_T92, dfa6_T95, 
    dfa6_T171, dfa6_T178, dfa6_T175, dfa6_T184, dfa6_T194, dfa6_T211, dfa6_T215, 
    dfa6_T5, dfa6_T5, dfa6_T5, dfa6_T208, dfa6_T84, dfa6_T72, dfa6_T66, 
    dfa6_T56, dfa6_T46, dfa6_T39, dfa6_T33, dfa6_T29, dfa6_T19, dfa6_T17, 
    dfa6_T160, dfa6_T162, dfa6_T135, dfa6_T139, dfa6_T125, dfa6_T131, dfa6_T120, 
    dfa6_T107, dfa6_T109, dfa6_T103, dfa6_T91, dfa6_T94, dfa6_T173, dfa6_T179, 
    dfa6_T190, dfa6_T183, dfa6_T195, dfa6_T5, dfa6_T214, NULL, NULL, NULL, 
    dfa6_T207, dfa6_T82, dfa6_T73, dfa6_T5, dfa6_T60, dfa6_T47, dfa6_T38, 
    dfa6_T31, dfa6_T26, dfa6_T5, dfa6_T13, dfa6_T158, dfa6_T163, dfa6_T136, 
    dfa6_T140, dfa6_T128, dfa6_T118, dfa6_T5, dfa6_T106, dfa6_T97, dfa6_T104, 
    dfa6_T88, dfa6_T5, dfa6_T172, dfa6_T180, dfa6_T189, dfa6_T182, dfa6_T192, 
    NULL, dfa6_T199, dfa6_T206, dfa6_T81, dfa6_T77, NULL, dfa6_T58, dfa6_T48, 
    dfa6_T37, dfa6_T5, dfa6_T27, NULL, dfa6_T14, dfa6_T159, dfa6_T147, dfa6_T5, 
    dfa6_T141, dfa6_T127, dfa6_T119, NULL, dfa6_T105, dfa6_T98, dfa6_T101, 
    dfa6_T87, NULL, dfa6_T168, dfa6_T181, dfa6_T188, dfa6_T5, dfa6_T193, 
    dfa6_T200, dfa6_T205, dfa6_T80, dfa6_T78, dfa6_T62, dfa6_T49, dfa6_T35, 
    NULL, dfa6_T24, dfa6_T15, dfa6_T5, dfa6_T146, NULL, dfa6_T142, dfa6_T129, 
    dfa6_T116, dfa6_T111, dfa6_T99, dfa6_T5, dfa6_T90, dfa6_T167, dfa6_T176, 
    dfa6_T187, NULL, dfa6_T191, dfa6_T197, dfa6_T83, dfa6_T79, dfa6_T75, 
    dfa6_T61, dfa6_T50, dfa6_T34, dfa6_T25, dfa6_T16, NULL, dfa6_T145, dfa6_T143, 
    dfa6_T5, dfa6_T117, dfa6_T5, dfa6_T100, NULL, dfa6_T89, dfa6_T170, dfa6_T177, 
    dfa6_T186, dfa6_T5, dfa6_T198, dfa6_T5, dfa6_T5, dfa6_T76, dfa6_T64, 
    dfa6_T51, dfa6_T5, dfa6_T23, dfa6_T9, dfa6_T144, dfa6_T5, NULL, dfa6_T114, 
    NULL, dfa6_T5, dfa6_T96, dfa6_T169, dfa6_T5, dfa6_T5, NULL, dfa6_T5, 
    NULL, NULL, dfa6_T70, dfa6_T63, dfa6_T43, NULL, dfa6_T22, dfa6_T10, 
    dfa6_T153, NULL, dfa6_T115, NULL, dfa6_T5, dfa6_T165, NULL, NULL, NULL, 
    dfa6_T71, dfa6_T52, dfa6_T42, dfa6_T5, dfa6_T11, dfa6_T152, dfa6_T112, 
    NULL, dfa6_T164, dfa6_T68, dfa6_T53, dfa6_T5, NULL, dfa6_T12, dfa6_T150, 
    dfa6_T113, dfa6_T166, dfa6_T69, dfa6_T54, NULL, dfa6_T3, dfa6_T148, 
    dfa6_T5, dfa6_T5, dfa6_T5, dfa6_T55, dfa6_T4, dfa6_T157, NULL, NULL, 
    NULL, dfa6_T5, dfa6_T6, dfa6_T156, NULL, dfa6_T7, dfa6_T155, dfa6_T0, 
    dfa6_T154, dfa6_T1, dfa6_T5, dfa6_T2, NULL, dfa6_T5, NULL
};


/* Declare tracking structure for Cyclic DFA 6
 */
class MorphDSL3LexerCyclicDFA6 : public CyclicDFA< MorphDSL3LexerImplTraits, MorphDSL3Lexer >, public MorphDSL3LexerTokens
{
public:
	typedef CyclicDFA< MorphDSL3LexerImplTraits, MorphDSL3Lexer >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	MorphDSL3LexerCyclicDFA6( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static MorphDSL3LexerCyclicDFA6  cdfa6(
	    6,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1:1: Tokens : ( T__9 | T__10 | T__11 | T__12 | T__13 | T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | T__29 | T__30 | T__31 | T__32 | T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | T__40 | T__41 | T__42 | T__43 | T__44 | T__45 | T__46 | ID | DOUBLENUMBER | WS | COMMENT );",
	    dfa6_eot,	    /* EOT table			    */
	    dfa6_eof,	    /* EOF table			    */
	    dfa6_min,	    /* Minimum tokens for each state    */
	    dfa6_max,	    /* Maximum tokens for each state    */
	    dfa6_accept,	/* Accept table			    */
	    dfa6_special,	/* Special transition states	    */
	    dfa6_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 6
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 32:6: ( '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__9
 *
 * Looks to match the characters the constitute the token T__9
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__9()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__9;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:32:6: ( '\"' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:32:8: '\"'
    {
         this->matchc('\"');
        if  (this->hasException())
        {
            goto ruleT__9Ex;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__9Ex; /* Prevent compiler warnings */
    ruleT__9Ex: ;

}
// $ANTLR end T__9

//   Comes from: 33:7: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__10
 *
 * Looks to match the characters the constitute the token T__10
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__10()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__10;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:33:7: ( '(' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:33:9: '('
    {
         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleT__10Ex;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__10Ex; /* Prevent compiler warnings */
    ruleT__10Ex: ;

}
// $ANTLR end T__10

//   Comes from: 34:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__11
 *
 * Looks to match the characters the constitute the token T__11
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__11()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__11;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:34:7: ( ')' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:34:9: ')'
    {
         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleT__11Ex;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__11Ex; /* Prevent compiler warnings */
    ruleT__11Ex: ;

}
// $ANTLR end T__11

//   Comes from: 35:7: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__12
 *
 * Looks to match the characters the constitute the token T__12
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__12()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__12;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:35:7: ( ',' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:35:9: ','
    {
         this->matchc(',');
        if  (this->hasException())
        {
            goto ruleT__12Ex;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__12Ex; /* Prevent compiler warnings */
    ruleT__12Ex: ;

}
// $ANTLR end T__12

//   Comes from: 36:7: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__13
 *
 * Looks to match the characters the constitute the token T__13
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__13()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__13;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:36:7: ( '=' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:36:9: '='
    {
         this->matchc('=');
        if  (this->hasException())
        {
            goto ruleT__13Ex;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__13Ex; /* Prevent compiler warnings */
    ruleT__13Ex: ;

}
// $ANTLR end T__13

//   Comes from: 37:7: ( 'AREA' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__14
 *
 * Looks to match the characters the constitute the token T__14
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__14()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__14;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:37:7: ( 'AREA' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:37:9: 'AREA'
    {
        this->matchs(lit_AREA);
        if  (this->hasException())
        {
            goto ruleT__14Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__14Ex; /* Prevent compiler warnings */
    ruleT__14Ex: ;

}
// $ANTLR end T__14

//   Comes from: 38:7: ( 'ATTRIBUTE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__15
 *
 * Looks to match the characters the constitute the token T__15
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__15()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__15;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:38:7: ( 'ATTRIBUTE' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:38:9: 'ATTRIBUTE'
    {
        this->matchs(lit_ATTRIBUTE);
        if  (this->hasException())
        {
            goto ruleT__15Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__15Ex; /* Prevent compiler warnings */
    ruleT__15Ex: ;

}
// $ANTLR end T__15

//   Comes from: 39:7: ( 'BOX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__16
 *
 * Looks to match the characters the constitute the token T__16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__16()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__16;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:39:7: ( 'BOX' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:39:9: 'BOX'
    {
        this->matchs(lit_BOX);
        if  (this->hasException())
        {
            goto ruleT__16Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__16Ex; /* Prevent compiler warnings */
    ruleT__16Ex: ;

}
// $ANTLR end T__16

//   Comes from: 40:7: ( 'DAP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__17
 *
 * Looks to match the characters the constitute the token T__17
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__17()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__17;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:40:7: ( 'DAP' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:40:9: 'DAP'
    {
        this->matchs(lit_DAP);
        if  (this->hasException())
        {
            goto ruleT__17Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__17Ex; /* Prevent compiler warnings */
    ruleT__17Ex: ;

}
// $ANTLR end T__17

//   Comes from: 41:7: ( 'DMP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__18
 *
 * Looks to match the characters the constitute the token T__18
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__18()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__18;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:41:7: ( 'DMP' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:41:9: 'DMP'
    {
        this->matchs(lit_DMP);
        if  (this->hasException())
        {
            goto ruleT__18Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__18Ex; /* Prevent compiler warnings */
    ruleT__18Ex: ;

}
// $ANTLR end T__18

//   Comes from: 42:7: ( 'EXTERNAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__19
 *
 * Looks to match the characters the constitute the token T__19
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__19()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__19;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:42:7: ( 'EXTERNAL' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:42:9: 'EXTERNAL'
    {
        this->matchs(lit_EXTERNAL);
        if  (this->hasException())
        {
            goto ruleT__19Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__19Ex; /* Prevent compiler warnings */
    ruleT__19Ex: ;

}
// $ANTLR end T__19

//   Comes from: 43:7: ( 'INTERNAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__20
 *
 * Looks to match the characters the constitute the token T__20
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__20()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__20;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:43:7: ( 'INTERNAL' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:43:9: 'INTERNAL'
    {
        this->matchs(lit_INTERNAL);
        if  (this->hasException())
        {
            goto ruleT__20Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__20Ex; /* Prevent compiler warnings */
    ruleT__20Ex: ;

}
// $ANTLR end T__20

//   Comes from: 44:7: ( 'MORPHOLOGICAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__21
 *
 * Looks to match the characters the constitute the token T__21
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__21()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__21;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:44:7: ( 'MORPHOLOGICAL' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:44:9: 'MORPHOLOGICAL'
    {
        this->matchs(lit_MORPHOLOGICAL);
        if  (this->hasException())
        {
            goto ruleT__21Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__21Ex; /* Prevent compiler warnings */
    ruleT__21Ex: ;

}
// $ANTLR end T__21

//   Comes from: 45:7: ( 'MSLS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__22
 *
 * Looks to match the characters the constitute the token T__22
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__22()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__22;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:45:7: ( 'MSLS' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:45:9: 'MSLS'
    {
        this->matchs(lit_MSLS);
        if  (this->hasException())
        {
            goto ruleT__22Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__22Ex; /* Prevent compiler warnings */
    ruleT__22Ex: ;

}
// $ANTLR end T__22

//   Comes from: 46:7: ( 'RECONSTRUCTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__23
 *
 * Looks to match the characters the constitute the token T__23
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__23()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__23;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:46:7: ( 'RECONSTRUCTION' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:46:9: 'RECONSTRUCTION'
    {
        this->matchs(lit_RECONSTRUCTION);
        if  (this->hasException())
        {
            goto ruleT__23Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__23Ex; /* Prevent compiler warnings */
    ruleT__23Ex: ;

}
// $ANTLR end T__23

//   Comes from: 47:7: ( 'WATHERSHADE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__24
 *
 * Looks to match the characters the constitute the token T__24
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__24()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__24;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:47:7: ( 'WATHERSHADE' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:47:9: 'WATHERSHADE'
    {
        this->matchs(lit_WATHERSHADE);
        if  (this->hasException())
        {
            goto ruleT__24Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__24Ex; /* Prevent compiler warnings */
    ruleT__24Ex: ;

}
// $ANTLR end T__24

//   Comes from: 48:7: ( 'boundary' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__25
 *
 * Looks to match the characters the constitute the token T__25
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__25()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__25;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:48:7: ( 'boundary' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:48:9: 'boundary'
    {
        this->matchs(lit_boundary);
        if  (this->hasException())
        {
            goto ruleT__25Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__25Ex; /* Prevent compiler warnings */
    ruleT__25Ex: ;

}
// $ANTLR end T__25

//   Comes from: 49:7: ( 'close' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__26
 *
 * Looks to match the characters the constitute the token T__26
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__26()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__26;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:49:7: ( 'close' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:49:9: 'close'
    {
        this->matchs(lit_close);
        if  (this->hasException())
        {
            goto ruleT__26Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__26Ex; /* Prevent compiler warnings */
    ruleT__26Ex: ;

}
// $ANTLR end T__26

//   Comes from: 50:7: ( 'complement' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__27
 *
 * Looks to match the characters the constitute the token T__27
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__27()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__27;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:50:7: ( 'complement' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:50:9: 'complement'
    {
        this->matchs(lit_complement);
        if  (this->hasException())
        {
            goto ruleT__27Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__27Ex; /* Prevent compiler warnings */
    ruleT__27Ex: ;

}
// $ANTLR end T__27

//   Comes from: 51:7: ( 'crop' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__28
 *
 * Looks to match the characters the constitute the token T__28
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__28()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__28;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:51:7: ( 'crop' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:51:9: 'crop'
    {
        this->matchs(lit_crop);
        if  (this->hasException())
        {
            goto ruleT__28Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__28Ex; /* Prevent compiler warnings */
    ruleT__28Ex: ;

}
// $ANTLR end T__28

//   Comes from: 52:7: ( 'diferentialProfiles' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__29
 *
 * Looks to match the characters the constitute the token T__29
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__29()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__29;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:52:7: ( 'diferentialProfiles' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:52:9: 'diferentialProfiles'
    {
        this->matchs(lit_diferentialProfiles);
        if  (this->hasException())
        {
            goto ruleT__29Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__29Ex; /* Prevent compiler warnings */
    ruleT__29Ex: ;

}
// $ANTLR end T__29

//   Comes from: 53:7: ( 'dilate' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__30
 *
 * Looks to match the characters the constitute the token T__30
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__30()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__30;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:53:7: ( 'dilate' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:53:9: 'dilate'
    {
        this->matchs(lit_dilate);
        if  (this->hasException())
        {
            goto ruleT__30Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__30Ex; /* Prevent compiler warnings */
    ruleT__30Ex: ;

}
// $ANTLR end T__30

//   Comes from: 54:7: ( 'distanceTransform' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__31
 *
 * Looks to match the characters the constitute the token T__31
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__31()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__31;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:54:7: ( 'distanceTransform' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:54:9: 'distanceTransform'
    {
        this->matchs(lit_distanceTransform);
        if  (this->hasException())
        {
            goto ruleT__31Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__31Ex; /* Prevent compiler warnings */
    ruleT__31Ex: ;

}
// $ANTLR end T__31

//   Comes from: 55:7: ( 'erode' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__32
 *
 * Looks to match the characters the constitute the token T__32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__32()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__32;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:55:7: ( 'erode' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:55:9: 'erode'
    {
        this->matchs(lit_erode);
        if  (this->hasException())
        {
            goto ruleT__32Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__32Ex; /* Prevent compiler warnings */
    ruleT__32Ex: ;

}
// $ANTLR end T__32

//   Comes from: 56:7: ( 'gradient' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__33
 *
 * Looks to match the characters the constitute the token T__33
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__33()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__33;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:56:7: ( 'gradient' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:56:9: 'gradient'
    {
        this->matchs(lit_gradient);
        if  (this->hasException())
        {
            goto ruleT__33Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__33Ex; /* Prevent compiler warnings */
    ruleT__33Ex: ;

}
// $ANTLR end T__33

//   Comes from: 57:7: ( 'hitmiss' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__34
 *
 * Looks to match the characters the constitute the token T__34
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__34()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__34;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:57:7: ( 'hitmiss' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:57:9: 'hitmiss'
    {
        this->matchs(lit_hitmiss);
        if  (this->hasException())
        {
            goto ruleT__34Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__34Ex; /* Prevent compiler warnings */
    ruleT__34Ex: ;

}
// $ANTLR end T__34

//   Comes from: 58:7: ( 'intersection' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__35
 *
 * Looks to match the characters the constitute the token T__35
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__35()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__35;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:58:7: ( 'intersection' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:58:9: 'intersection'
    {
        this->matchs(lit_intersection);
        if  (this->hasException())
        {
            goto ruleT__35Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__35Ex; /* Prevent compiler warnings */
    ruleT__35Ex: ;

}
// $ANTLR end T__35

//   Comes from: 59:7: ( 'load' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__36
 *
 * Looks to match the characters the constitute the token T__36
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__36()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__36;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:59:7: ( 'load' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:59:9: 'load'
    {
        this->matchs(lit_load);
        if  (this->hasException())
        {
            goto ruleT__36Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__36Ex; /* Prevent compiler warnings */
    ruleT__36Ex: ;

}
// $ANTLR end T__36

//   Comes from: 60:7: ( 'mapping' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__37
 *
 * Looks to match the characters the constitute the token T__37
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__37()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__37;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:60:7: ( 'mapping' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:60:9: 'mapping'
    {
        this->matchs(lit_mapping);
        if  (this->hasException())
        {
            goto ruleT__37Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__37Ex; /* Prevent compiler warnings */
    ruleT__37Ex: ;

}
// $ANTLR end T__37

//   Comes from: 61:7: ( 'multiply' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__38
 *
 * Looks to match the characters the constitute the token T__38
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__38()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__38;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:61:7: ( 'multiply' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:61:9: 'multiply'
    {
        this->matchs(lit_multiply);
        if  (this->hasException())
        {
            goto ruleT__38Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__38Ex; /* Prevent compiler warnings */
    ruleT__38Ex: ;

}
// $ANTLR end T__38

//   Comes from: 62:7: ( 'negate' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__39
 *
 * Looks to match the characters the constitute the token T__39
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__39()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__39;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:62:7: ( 'negate' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:62:9: 'negate'
    {
        this->matchs(lit_negate);
        if  (this->hasException())
        {
            goto ruleT__39Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__39Ex; /* Prevent compiler warnings */
    ruleT__39Ex: ;

}
// $ANTLR end T__39

//   Comes from: 63:7: ( 'normalize' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__40
 *
 * Looks to match the characters the constitute the token T__40
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__40()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__40;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:63:7: ( 'normalize' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:63:9: 'normalize'
    {
        this->matchs(lit_normalize);
        if  (this->hasException())
        {
            goto ruleT__40Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__40Ex; /* Prevent compiler warnings */
    ruleT__40Ex: ;

}
// $ANTLR end T__40

//   Comes from: 64:7: ( 'open' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__41
 *
 * Looks to match the characters the constitute the token T__41
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__41()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__41;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:64:7: ( 'open' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:64:9: 'open'
    {
        this->matchs(lit_open);
        if  (this->hasException())
        {
            goto ruleT__41Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__41Ex; /* Prevent compiler warnings */
    ruleT__41Ex: ;

}
// $ANTLR end T__41

//   Comes from: 65:7: ( 'segmentation' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__42
 *
 * Looks to match the characters the constitute the token T__42
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__42()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__42;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:65:7: ( 'segmentation' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:65:9: 'segmentation'
    {
        this->matchs(lit_segmentation);
        if  (this->hasException())
        {
            goto ruleT__42Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__42Ex; /* Prevent compiler warnings */
    ruleT__42Ex: ;

}
// $ANTLR end T__42

//   Comes from: 66:7: ( 'subtract' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__43
 *
 * Looks to match the characters the constitute the token T__43
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__43()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__43;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:66:7: ( 'subtract' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:66:9: 'subtract'
    {
        this->matchs(lit_subtract);
        if  (this->hasException())
        {
            goto ruleT__43Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__43Ex; /* Prevent compiler warnings */
    ruleT__43Ex: ;

}
// $ANTLR end T__43

//   Comes from: 67:7: ( 'treshold' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__44
 *
 * Looks to match the characters the constitute the token T__44
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__44()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__44;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:67:7: ( 'treshold' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:67:9: 'treshold'
    {
        this->matchs(lit_treshold);
        if  (this->hasException())
        {
            goto ruleT__44Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__44Ex; /* Prevent compiler warnings */
    ruleT__44Ex: ;

}
// $ANTLR end T__44

//   Comes from: 68:7: ( 'union' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__45
 *
 * Looks to match the characters the constitute the token T__45
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__45()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__45;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:68:7: ( 'union' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:68:9: 'union'
    {
        this->matchs(lit_union);
        if  (this->hasException())
        {
            goto ruleT__45Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__45Ex; /* Prevent compiler warnings */
    ruleT__45Ex: ;

}
// $ANTLR end T__45

//   Comes from: 69:7: ( 'without' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__46
 *
 * Looks to match the characters the constitute the token T__46
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mT__46()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__46;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:69:7: ( 'without' )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:69:9: 'without'
    {
        this->matchs(lit_without);
        if  (this->hasException())
        {
            goto ruleT__46Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__46Ex; /* Prevent compiler warnings */
    ruleT__46Ex: ;

}
// $ANTLR end T__46

//   Comes from: 152:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '\\\\' | '.' | ':' )+ ( '[' NUMBER ']' )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mID()
{
    ANTLR_UINT32	_type;
      


    _type	    = ID;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:152:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '\\\\' | '.' | ':' )+ ( '[' NUMBER ']' )? )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:152:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '\\\\' | '.' | ':' )+ ( '[' NUMBER ']' )?
    {
        // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:152:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '\\\\' | '.' | ':' )+
        {
            int cnt1=0;

            for (;;)
            {
                int alt1=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA1_0 = this->LA(1);
        	    if ( (LA1_0 == '.' || LA1_0 == ':' || ((LA1_0 >= 'A') && (LA1_0 <= 'Z')) || LA1_0 == '\\' || LA1_0 == '_' || ((LA1_0 >= 'a') && (LA1_0 <= 'z'))))
        	    {
        	        alt1=1;
        	    }

        	}
        	switch (alt1)
        	{
        	    case 1:
        	        // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:
        	        {
        	            if ( this->LA(1) == '.' || this->LA(1) == ':' || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '\\' || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< MorphDSL3LexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleIDEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt1 >= 1 )
        		{
        		    goto loop1;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< MorphDSL3LexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleIDEx;
        	}
        	cnt1++;
            }
            loop1: ;	/* Jump to here if this rule does not match */
        }

        // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:152:52: ( '[' NUMBER ']' )?
        {
            int alt2=2;
            {
                int LA2_0 = this->LA(1);
                if ( (LA2_0 == '['))
                {
                    alt2=1;
                }
            }
            switch (alt2)
            {
        	case 1:
        	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:152:53: '[' NUMBER ']'
        	    {
        	         this->matchc('[');
        	        if  (this->hasException())
        	        {
        	            goto ruleIDEx;
        	        }


        	        /* 152:53: '[' NUMBER ']' */
        	        mNUMBER();
        	        if  (this->hasException())
        	        {
        	            goto ruleIDEx;
        	        }



        	         this->matchc(']');
        	        if  (this->hasException())
        	        {
        	            goto ruleIDEx;
        	        }


        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
    ruleIDEx: ;

}
// $ANTLR end ID

//   Comes from: 157:2: ( NUMBER ( '.' NUMBER )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLENUMBER
 *
 * Looks to match the characters the constitute the token DOUBLENUMBER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mDOUBLENUMBER()
{
    ANTLR_UINT32	_type;
      


    _type	    = DOUBLENUMBER;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:157:2: ( NUMBER ( '.' NUMBER )? )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:157:4: NUMBER ( '.' NUMBER )?
    {
        /* 157:4: NUMBER ( '.' NUMBER )? */
        mNUMBER();
        if  (this->hasException())
        {
            goto ruleDOUBLENUMBEREx;
        }



        // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:157:11: ( '.' NUMBER )?
        {
            int alt3=2;
            {
                int LA3_0 = this->LA(1);
                if ( (LA3_0 == '.'))
                {
                    alt3=1;
                }
            }
            switch (alt3)
            {
        	case 1:
        	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:157:12: '.' NUMBER
        	    {
        	         this->matchc('.');
        	        if  (this->hasException())
        	        {
        	            goto ruleDOUBLENUMBEREx;
        	        }


        	        /* 157:12: '.' NUMBER */
        	        mNUMBER();
        	        if  (this->hasException())
        	        {
        	            goto ruleDOUBLENUMBEREx;
        	        }



        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDOUBLENUMBEREx; /* Prevent compiler warnings */
    ruleDOUBLENUMBEREx: ;

}
// $ANTLR end DOUBLENUMBER

//   Comes from: 160:17: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NUMBER
 *
 * Looks to match the characters the constitute the token NUMBER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mNUMBER()
{
    ANTLR_UINT32	_type;
      



    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:160:17: ( ( '0' .. '9' )+ )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:160:19: ( '0' .. '9' )+
    {
        // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:160:19: ( '0' .. '9' )+
        {
            int cnt4=0;

            for (;;)
            {
                int alt4=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA4_0 = this->LA(1);
        	    if ( (((LA4_0 >= '0') && (LA4_0 <= '9'))))
        	    {
        	        alt4=1;
        	    }

        	}
        	switch (alt4)
        	{
        	    case 1:
        	        // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:
        	        {
        	            if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< MorphDSL3LexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleNUMBEREx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt4 >= 1 )
        		{
        		    goto loop4;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< MorphDSL3LexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleNUMBEREx;
        	}
        	cnt4++;
            }
            loop4: ;	/* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleNUMBEREx; /* Prevent compiler warnings */
    ruleNUMBEREx: ;

}
// $ANTLR end NUMBER

//   Comes from: 162:4: ( ( ' ' | '\\t' | '\\n' | '\\r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mWS()
{
    ANTLR_UINT32	_type;
      


    _type	    = WS;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:162:4: ( ( ' ' | '\\t' | '\\n' | '\\r' ) )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:162:9: ( ' ' | '\\t' | '\\n' | '\\r' )
    {
        if ( ((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || this->LA(1) == '\r' || this->LA(1) == ' ' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< MorphDSL3LexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleWSEx;
        }


        {
             skip(); 
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

//   Comes from: 164:10: ( '/' '/' (~ ( '\\r' | '\\n' ) )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void MorphDSL3Lexer::mCOMMENT()
{
    ANTLR_UINT32	_type;
      


    _type	    = COMMENT;


    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:164:10: ( '/' '/' (~ ( '\\r' | '\\n' ) )* )
    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:164:12: '/' '/' (~ ( '\\r' | '\\n' ) )*
    {
         this->matchc('/');
        if  (this->hasException())
        {
            goto ruleCOMMENTEx;
        }


         this->matchc('/');
        if  (this->hasException())
        {
            goto ruleCOMMENTEx;
        }


        // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:164:20: (~ ( '\\r' | '\\n' ) )*

        for (;;)
        {
            int alt5=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA5_0 = this->LA(1);
//                if ( (((LA5_0 >= '\u0000') && (LA5_0 <= '\t')) || ((LA5_0 >= '\u000B') && (LA5_0 <= '\f')) || ((LA5_0 >= '\u000E') && (LA5_0 <= '\uFFFF'))))
                if ( (((LA5_0 >= L'\0') && (LA5_0 <= '\t')) || ((LA5_0 >= L'\B') && (LA5_0 <= '\f')) || ((LA5_0 >= L'\E') && (LA5_0 <= '\uFFFF'))))
                {
                    alt5=1;
                }

            }
            switch (alt5)
            {
        	case 1:
        	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:
        	    {
//        	        if ( ((this->LA(1) >= '\u0000') && (this->LA(1) <= '\t')) || ((this->LA(1) >= '\u000B') && (this->LA(1) <= '\f')) || ((this->LA(1) >= '\u000E') && (this->LA(1) <= '\uFFFF')) )
        	        if ( ((this->LA(1) >= L'\0') && (this->LA(1) <= '\t')) || ((this->LA(1) >= L'\B') && (this->LA(1) <= '\f')) || ((this->LA(1) >= L'\E') && (this->LA(1) <= '\uFFFF')) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< MorphDSL3LexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop5;	/* break out of the loop */
        	    break;
            }
        }
        loop5: ; /* Jump out to here if this rule does not match */


        {
             skip(); 
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
MorphDSL3Lexer::mTokens()
{
    {
        //  C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:8: ( T__9 | T__10 | T__11 | T__12 | T__13 | T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | T__29 | T__30 | T__31 | T__32 | T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | T__40 | T__41 | T__42 | T__43 | T__44 | T__45 | T__46 | ID | DOUBLENUMBER | WS | COMMENT )

        ANTLR_UINT32 alt6;

        alt6=42;

        alt6 = cdfa6.predict(this, this->get_rec(), this->get_istream(), cdfa6 );
        if  (this->hasException())
        {
            goto ruleTokensEx;
        }

        switch (alt6)
        {
    	case 1:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:10: T__9
    	    {
    	        /* 1:10: T__9 */
    	        mT__9();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:15: T__10
    	    {
    	        /* 1:15: T__10 */
    	        mT__10();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:21: T__11
    	    {
    	        /* 1:21: T__11 */
    	        mT__11();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:27: T__12
    	    {
    	        /* 1:27: T__12 */
    	        mT__12();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:33: T__13
    	    {
    	        /* 1:33: T__13 */
    	        mT__13();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:39: T__14
    	    {
    	        /* 1:39: T__14 */
    	        mT__14();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:45: T__15
    	    {
    	        /* 1:45: T__15 */
    	        mT__15();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:51: T__16
    	    {
    	        /* 1:51: T__16 */
    	        mT__16();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:57: T__17
    	    {
    	        /* 1:57: T__17 */
    	        mT__17();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:63: T__18
    	    {
    	        /* 1:63: T__18 */
    	        mT__18();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:69: T__19
    	    {
    	        /* 1:69: T__19 */
    	        mT__19();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:75: T__20
    	    {
    	        /* 1:75: T__20 */
    	        mT__20();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:81: T__21
    	    {
    	        /* 1:81: T__21 */
    	        mT__21();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:87: T__22
    	    {
    	        /* 1:87: T__22 */
    	        mT__22();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:93: T__23
    	    {
    	        /* 1:93: T__23 */
    	        mT__23();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:99: T__24
    	    {
    	        /* 1:99: T__24 */
    	        mT__24();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:105: T__25
    	    {
    	        /* 1:105: T__25 */
    	        mT__25();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:111: T__26
    	    {
    	        /* 1:111: T__26 */
    	        mT__26();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:117: T__27
    	    {
    	        /* 1:117: T__27 */
    	        mT__27();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:123: T__28
    	    {
    	        /* 1:123: T__28 */
    	        mT__28();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:129: T__29
    	    {
    	        /* 1:129: T__29 */
    	        mT__29();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:135: T__30
    	    {
    	        /* 1:135: T__30 */
    	        mT__30();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:141: T__31
    	    {
    	        /* 1:141: T__31 */
    	        mT__31();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:147: T__32
    	    {
    	        /* 1:147: T__32 */
    	        mT__32();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:153: T__33
    	    {
    	        /* 1:153: T__33 */
    	        mT__33();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:159: T__34
    	    {
    	        /* 1:159: T__34 */
    	        mT__34();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:165: T__35
    	    {
    	        /* 1:165: T__35 */
    	        mT__35();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:171: T__36
    	    {
    	        /* 1:171: T__36 */
    	        mT__36();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:177: T__37
    	    {
    	        /* 1:177: T__37 */
    	        mT__37();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:183: T__38
    	    {
    	        /* 1:183: T__38 */
    	        mT__38();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 31:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:189: T__39
    	    {
    	        /* 1:189: T__39 */
    	        mT__39();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 32:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:195: T__40
    	    {
    	        /* 1:195: T__40 */
    	        mT__40();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 33:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:201: T__41
    	    {
    	        /* 1:201: T__41 */
    	        mT__41();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 34:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:207: T__42
    	    {
    	        /* 1:207: T__42 */
    	        mT__42();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 35:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:213: T__43
    	    {
    	        /* 1:213: T__43 */
    	        mT__43();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 36:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:219: T__44
    	    {
    	        /* 1:219: T__44 */
    	        mT__44();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 37:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:225: T__45
    	    {
    	        /* 1:225: T__45 */
    	        mT__45();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 38:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:231: T__46
    	    {
    	        /* 1:231: T__46 */
    	        mT__46();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 39:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:237: ID
    	    {
    	        /* 1:237: ID */
    	        mID();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 40:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:240: DOUBLENUMBER
    	    {
    	        /* 1:240: DOUBLENUMBER */
    	        mDOUBLENUMBER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 41:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:253: WS
    	    {
    	        /* 1:253: WS */
    	        mWS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 42:
    	    // C:\\Users\\Tomaz\\Desktop\\Morph\\MorphDSL3.g:1:256: COMMENT
    	    {
    	        /* 1:256: COMMENT */
    	        mCOMMENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */

	}



/* End of code
 * =============================================================================
 */
